  
    vue实例下的属性中，在他们的属性值里面的函数调用this就是vue实例本身，然后实例本身里有个属性$option 这个属性的值就是个对象，这个对象就是vue实例下写的什么el data methods等等
                     vue的数据都是默认带双向绑定的 它的原理就是运用js中的数据劫持，object.difiendprotype()
                     
  
    指令：本质就是一个自定义属性，然后可以可以把复杂的操作简单化.vue的数据都是默认带双向绑定的  指令的值默认都是Vue中变量的，如果不想这样，就加引号
         v-cloak：消除抖动，因为指令是写在html元素里面的，页面加载时候，会先加载指令，再加载到script里面的Vue，所以还没加载到Vue时候，就会出现问题，这就是抖动的原因，
                            用法是在Vue的el元素加了后，然后还要在样式style里面写固定格式  【vb-cloak】【display：none】
         v-text：纯文本填写 ：<span v-text="msg"></span>
         v-once:让元素上的数据失去双向绑定的效果 
         v-bind：<a v-bind:href="url" v-bind:target="target">{{alt}}</a>   简写： <a :href="url" :target="target">{{alt}}</a>  让某个属性变成动态的
         v-on :事件绑定： <button v-on:click="num++"></button>  简写：<button @click="num++"></buttton>   
                         事件函数时候： <button @click="say"></button>     对于传参的情况，如果在methods里面写的方法
                                        实际不需要参数，那么你可以根据自己需求在里面加一个参数，那么这么参数在这个函数里就是事件对象，如果本身就需要参数，那就正常加参数，如果同时还需要时间对象的话，那就是最后一个参数是事件对象参数
                                       然后在元素里调用的时候，必须最后一个实参要写$event   例如:  <button @click="say('参数' ，$event)"></button>
         v-for:一般就用在遍历数组上面，一般不会遍历对象，这个循环就是根据数组的个数循环这个元素的感觉，不是单纯的循环数据
                <div v-for="(item , index)in arr"  :key="index" > {{item}} </div>  最后的 ：key就是v-bind的简写，一般要写，值是个唯一值就行

         v-if、v-else-if :用法：<div v-if=" a>1 "></div>  <div v-else-if="a<2"></div>  分别绑定在不同元素上面，哪个满足了，哪个就会显示
         v-show：         用法：<div v-show=" a>1 " ></div>  里面只要是个ture 就会显示，
                          这两个都是控制元素显示和不显示的，v-if的原理就是如果不显示，那么元素根本就不会渲染，v-show其实就是给不显示的元素加了display：none
                          如果以后还会让不显示的元素显示，那么就用v-show，否则用v-if

         v-model: 主要针对是input框，因为一般的双向数据绑定时候，只有input框才会改变前端的页面数据，也就是input事件，这玩意意思就是input事件绑定好了，后面的属性值就是框里的数据，不是事件	
         v-model.lay:这个是失焦的时候才会触发，就是说失焦时候，vue里的数具才会变

                  普通输入框：<input type="text"  v-model="mes"/>   这时候的mes就是Vue中的数据 ，这个值也就是事实input框中的数据
                  多行文本域：<textarea v-model="mes" ></textarea>  同上，mes的值就是文本域的实时数据，如果用插值表达式写在两个标签中间，是没有双向数据性质的
                  单个复选框（全选按钮时候）：<input type="checkbox" v-model="mes"/>  这里的mes是Vue的数据，这个值是个布尔值，就代表选中还是没有选中
                  多个复选框：<input type="checkbox" value="a" v-model="arr">  <input type="checkbox" value="b" v-model="arr" />
                           这里的arr是Vue的数据，值一定是一个数组，然后每个CheckBox的value值，如果在这个数组中，就是表示被选中，否则就是没选中
                  单选按钮：<input type="radio" value='a' v-model="mes">  以前时候，必须要有name属性做关联，现在不用了，现在就是用mes的值跟value做比较，值一样的话就选中
                  下拉框：<select v-model="mes">
                              <option>test</option>   加在select的标签上面的，这里面的Vue数据mes的值跟哪个的文本一模一样，就选中哪个
                           </select>
                  
    

         事件修饰 阻止冒泡：<button @click.stop="doThis"></button>  阻止默认行为  <button @click.prevent="doThis"></button>
         按键修饰符：<input v-on:keyup.enter="submit"> 只有key是enter时候触发事件  
                    <input v-on:keyup.delete="handle">同样，在按下delete时候触发  一般用在input框的时候  其他地方用，基本上都是没有效果的

         class名的处理：开关类型，就是控制这个类名在这个元素上面有还是没有的情况，经常用到  ：<div :class="{show:toggle}"> 文字 </div>   其中-这个show就是在css里面写好的样式名字，值就是Vue中的属性，这个属性值一都是TRUE或者false，这样就控制了到底有没有这个样式了  记住，这玩意控制的show，也就是样式名字，一定是能是类的，也就是这样样式在style里面写的时候一定是  .xxxx
                       数组类型，就是把多个样式名写在一个Vue的数据中，这样可以想用哪个用哪个样式 <div :class="[yanse , font]">  </div>  其中这个数组里面的值，是Vue数据中的属性名 然后这个属性名的值就一定要是css样式中的某个样式名，这样就控制了元素可以一下运用几个样式了

         正常的样式处理（style样式）：跟上面一样，有对象跟数组两种写法 对象写法：<div :style='{color:fontcolor , font-size:’20px‘}' ></div>  
                       其中，对象里的属性值就是正常的你想整的样式名字（不是样式值） 然后值，不管是什么，如果不加引号，都是认为是数据里的数据名称！！！！！！,有连字符的属性名要换成驼峰写法
         数组样式处理  <div :style="[color , font]"></div>  这里的数组里的值，就是Vue的数据，然后这个数据的值，就是css样式的写法 ，就相当于吧css样式写的东西搬到了Vue中的数据了          


         自定义属性： 钩子函数 一般有两个参数，参数1 ：el 是被绑的dom级的元素本身，参数2:binding 是指令的本身信息，这个信息里，有个value值，这个值就是钩子函数在调用时候传递的实参
                              也就是说，在钩子函数里面可以通过 binding.value 就是传递的实参数据   钩子函数里的this指向的是window对象
                              bind：function（参数1 ， 参数2）{} 指令第一次绑定到元素上的时候触发 这个不可以获取到被绑元素的父元素，因为第一个参数就是被绑元素dom
                              inserted：function（）{}   被绑定的元素插入父元素的时候触发    可以获取到被绑元素的父元素
                              update：function（）{}  在数据改变的时候触发
         
                  全局的写法：写在Vue实例之前  vue.directive(指令名字 ，{钩子函数，可以写多个钩子函数})  
                  局部写法，就是自Vue实例里添加属性 directives：{ 指令名：{指令的钩子函数1，指令的钩子函数2} }
                  用的时候直接在元素里写v-指令名就行

         计算属性：<div> {{fn}} </div>      methods:{xxxx}, 
                                             computed:{ fn(){xxx},} 计算属性的书写跟methods一模一样，但是函数里一定要写return   用法跟data中的用法一抹一眼，但是在用的是，不能像方法一样加（）

         watch监听：默认就是监听data里面表面的数据，就是监听不了数组，对象里的数据  watch：{ 被监听的data数据：function（参数1 ， 参数2）{} }   参数1是改变后的新值，参数2是之前的旧值
                        如果想要深度监听，那么语法就是   watch：{ 被监听的数组或对象 ：{  handler（）{} }  , deep:true}  这个处理函数名字只能是handler，里面参数也是只能有一个，就是代表前面被监听的数组或者对象，这时候他们里面数据变了，也会触发了
         
         计算属性跟watch的区别：计算属性默认旧支持深度监听,而且计算属性它只要数据不变，是会存缓存的，不会重新加载数据

         过滤器：它也有全局跟局部，全局： vue.fliter("过滤器的名字" ， function（val）{})  过滤器的处理函数里面最少得要有一个参数，这个参数就是要处理的数据,而已跟计算属性一样，必须要有return
                                 局部：  fliters：{ 过滤器名字1：function（val ， 形参2...）{} ，  }
                                 使用的时候： <div> {{ 数据|过滤器1过滤器2 }} </div>
                                    过滤器的全局跟局部跟自定义属性基本一样，然后它的语法跟计算属性一模一样，使用的时候跟插值表达式一样，那个竖号前面的会默认当做处理函数的第一个参数，也就是需要处理的数据，支持链式调用
                                    ！！！过滤器的返回值，不能写把原数据改变后再return出去，就是比如，不能写 el++ 这就是把源数据都改了，只能写el+1  这时候返回的不是源数据，是处理后的数据

         混入：这玩意的主要作用就是把vue中的属性（data 、 methods这些），写在外面，然后再根据实际需要，引进vue实例中，这就实现了复用的性质，全局写法
               Vue.mixin{ filters{ test:function(){} } }  这个全局的写法一般不用，这意思就是所有的vue实例，都会自动添加
               一般用局部的，就是谁用谁调  先在script标签里定义好  let mymix={ data:{} , methods:{}}  然后在vue实例中添加属性 mixins:[ mymix, ]
                 这里第一次用到vue实例中的属性值不是对象，而是数组，然后里面可以写好几个定义好的，放数组里就行，就这么简单

         生命周期：每个生命周期函数就是vue中单独的属性一样，直接写  元素创建前 beforCreate（）{}   创建后 created（）{} 请求一般发送这儿，早接受早展示   挂在前：beforMount（）{}  挂在后 mounted
                                                               data数据变化前：beforUpdate      数据变化后 update
                                                               销毁前 beforDestory  可用于防止重复加载/或者发送请求等    销毁后 destory

         组件： 这玩意就是相当于一个自定义的标签，所以用法就跟一般标签一样，用《》《/》这样的形式。   vue的实例可以看做一个根组件
               全局组件，意思就是说，可以在所有的vue的实例里面使用，别放在vue实例的外面了，那可不行 
                     Vue.component（“组件名” ， { 
                           data：function（）{ xxx  return { mes：xxx ， a：xxx } }，  这里，在写数据data的时候，一定要是个有return的函数，而且return的值必须是个对象，里面就是数据
                           filter：xxx，
                           methods:xxx，
                           template：`<div>{{mes}}</div>`  这个地方，使用末班字符串，不然变量不好写，这里就是相当于到时候这个自定义标签里的具体内容，这里的mes就是上面data数据里返回的  而且这个地方的html结构，必须有且只有一个最大的元素，就是里面的最大的父元素不能有同等级的其他的
                        }） 
                        使用这个组件就是单纯的在vue绑定的那个元素下写  《组件名》《/组件名》
                
               局部组件：就是先在外面定义好一个组件，然后哪个vue实例用，就把这个组件引用到自己里面，跟全局有点像，也跟前面的自定义属性有点像，
                        在script里面定义好一个组件 var 组件名={ 这里就是上面的第二个参数一模一样写法 就是直接写什么data啊这些 }    ！！！！！这里定义的组件名不是最后用的时候写的标签名
                        然后第二步这里要注册组件，说白了就是把这个组件放在哪个vue实例中去  这写法就是在vue实例中，再添加一个属性 
                           data：{} ，components：{    
                              真正用的时候的标签名1 ：上面在外面写好的组件名1，
                              真正用的时候的标签名1 ：上面在外面写好的组件名1，  也就是说，这里可以写多个组件，
                           } 
                           然后用法跟第一个一样，到时候写的标签名就是这里写的，也就是这个components里面的属性名


               组件这个玩意儿，在你写好标签后，就是会用template里面的内容完全替代了标签的，所以你在这个标签里再写东西，其实都没有意义的，
               比如 《test》5555《/test》这样写 最后这个没意义的，这里最终是完全被test这个组件的template代替的


               组件的复用：就是在一个组件里使用另一个组件，组件组件，说白了最后展示的部分不就是它里面的template部分嘛，所以复用，就是把被复用的组件直接写在另一个的template里去
                          template：`<div> <child></child> </div>`  这里的child就是另一个组件，注意，不能这样写 <div></div><child></child>  因为把后面组件这样融合后会发现，这个的template里
                          就已经违反了只能有且一个最高级父级了。。。。而且复用组件时候，被复用的要在事先在前面，就是先声明后使用一样

          vue 传值方式：因为vue的模块是分治的，而且数据也是独立性的，所以这时候如果在组合模板的时候，需要一个模板用另一个模板的数据，就要传值了

                     父传子： 就是这个所谓的子组件啊，到时候要写在这个父组件绑定的标签下面去，不然咋个叫父传子
                             首先就是用动态属性搞一个属性（v-bind：test=“！！！！这个值就是父元素里要传来的数据”  简写 ：test=“”），绑在子元素上面（也就是到时候要写的这个组件元素上面）
                             再然后，在子组件里写个属性props来接收上面搞得那个动态属性的名字
                       子：Vue.component("child" , {
                        props:{                   这是props的对象写法，这个可以设置默认值，就是如果这个动态属性绑定的父元素没有传来值，就用默认值，
                           test:{
                              default：“”，        这就是写默认值的地方
                              type：               这是说这个父元素传来的值得数据类型，如果传来的不是这个数据类型，显示不会有问题，但是后台会报错
                           }
                        }，
                        template：` XXXX `
                       })   
                       props的数组写法，就很简单props：[“动态绑定的属性名字1 test” ，... ]  
                       然后在使用的时候 就写 <child v:test=“这里就是父传来的值”></div>  然后它本身的template如果想用这个数据，就跟正常的data用法一样  就是比如 `<div :test="mes"> {{test}}</div> `
                                                     
                     子传父：这个的原理，就是先在子组件身上搞一个自定义的事件，然后这个自定义事件的处理函数写在父组件里，同时写这个处理函数里传参数，那么这个参数到时候不就是子组件传来的了嘛
                            这个问题就是在于，怎么写这个定义事件，语法是用  this.emit（“自定义事件的名字” ， 参数）
                            还有个问题就是，定义了这个自定义事件，那么这自定义事件啥时候触发呢，这个就是自定义事件啊，它一般写在常规的事件处理函数里，只要这时候常规事件触发了，它在里面也就跟着触发了
                            还有个问题，就是，这时候就算是自定义事件触发了，这时候它要找它的处理函数去了，但是它定义的时候this.emit时候，根本就没有自己的处理函数，而且其实知道，它的处理函数要写到父元素下的
                            这时候怎么整呢  那么就是这时候不就是这个自定义事件在触发状态了嘛  那我在子元素，也就是子模块的标签上给他加一个这个事件 @自定义事件=‘事件处理函数’  这时候因为子组件是在父组件下的
                            所以这时候它是可以往上找的，就会找到父里面有它自己的处理函数，  

                     eventbus事件中心： 这个原理跟上面的这个基本上一样的，也是通过事件来传递的，这个的适用范围就是基本上任意两个组件都行，这个步骤呢，也简单，就是先搞一个事件中心，也就是个单纯的vue实例
                                       然后跟上面一样，在传数据的组件上面搞个自定义事件，一样的这个自定义事件也是写在一个常规的事件的处理函数里，然后，再由接收的这个组件里接收这个自定义的事件处理函数，
                                       同样的问题，就是这个自定义的事件处理函数怎写，上面的方式呢用的是还是绑在被传数据的组件身上，这里可以直接用this.on(事件名 ， 事件处理函数)  把这个直接写在接收的组件里
                                       但是不能直接写在methods里，因为那里的函数是调用用的，而是直接写在created生命周期里，最后不用的时候，把这个事件处理中心销毁，它就传不了数据了，具体写法如下
                                          1、先创建一个事件中心  var eventBus=new Vue（）   这就是个事件中心，啥也不用多些
                                          2、 传数据组件的那个template里先触发一个常规的事件  template：` <div @click="clickHandler"> </div> `
                                          3、 然后在传数据的实例中的methods里定义好这个常规事件的处理函数，但是这个里面写一个自定义事件  methods：{ clickHandler（）{ eventBus.$emit("自定义的事件名test" ，（需要传的参数，比如data里的mes） ) } }
                                          4、然后这时候只要在需要接收数据的那个组件里写这个自定义函数的监听，也就是处理函数，写在created里   created（）{ eventBus.$on("前面那个自定义事件的名字test" （val）={ 处理函数里就接收到了，参数val，就是mes} ) }
                                          5、最后啥时候不用传递了，就销毁这个事件中心  eventBus.off（‘要销毁的事件，也就是前面的test’） 如果双向传递数据，就得要销毁两个

                     ref:   这个呢，就是说的是父组件去子组件里拿值，首先在子组件里写一个属性 ref 它的值呢随便定义，而且不仅仅是组件里可以写，你在这个父组件下写的其他正常html标签
                           上面也可以写这个属性，然后属性值都是随意写   然后父组件拿，它拿的方式就很简单，就是简单的在父组件的任何函数里写this.refs.属性名  这也就是说，父组件里的this.refs
                           就是它里面所有东西包括正常html标签写的所有ref的属性值   然后点到哪个就是拿哪个，而且恐怖的是，如果是点的组件的，那拿到的是整个组件实例..要想要数据，再接着 . 就行 如果是正常html
                           的ref的，那么就是拿到这个个dom元素，那就好办了，就可以正常dom操作了。....所以这个操作不仅仅是拿到数据，而已可以修改.....看着点用  
                                 语法： 先在子元素或者子组件下写一个ref属性 值随意  <child ref="test"></child>  这是个组件是吧
                                       然后父组价要用上面的数据就是在父组件里写   this.$refs.test  这玩意拿到的就是整个子组件....再接着点 this.$refs.test._data.mes  这就是把子组件里data里的mes数据都改了...

                     动态组件：这个玩意就是，几个组件显示在同一块区域，这块区域就是vue内置的一个特殊标签（在vue中标签不就是内置的自定义组件嘛） <compoent :is="动态值"> </component>  然后这个is的动态值就是具体的组件名
                              这就是说，像选项卡的那个下面的大框框，那个区域每次只会显示一个框
                              然后这个内置标签还会被另外一个内置标签 <keep-alive></keep-alive>  包着 如果包着，就意味着，只要被放进去过里面这个component的组件都会被缓存了一份，下次再切换到这个组件时候，不会重新再走一遍
                              被生命周期了，就用了缓存了，这样会优化体验，但是注意，这样里面那个被缓存的组件走不了生命周期的，也就是不会有created,等等这些函数了
                              还有一点，这个 <keep-alive> 自己还有两个生命周期函数，就是，在component里面的组件，每次被调用前会触发actived（）{}函数，还有每次被停用（也就是切换到其他组件时候，这个组件就是被停用了）时候触发 deactived（）{}
                              这啥意思呢，就是比如选项卡，一开始默认是显示第一个选项卡，然后当我切换到第二个选项卡的时候，这时候第二个选项卡就会触发被调用前的函数actived  原来的第一个就会触发被停用的那个函数deavtived
                              所以这也能看出来，这两个函数其实是写在每个组件里的，就是直接写。跟生命周期函数一样的 就是哪个组件需要就写，这样的目的就是在被调用或者被停用前做些事情或者传递数据给下一个用

               匿名/具名插槽： 匿名插槽：这玩意很简单，是父组件往子组件里传值的一种方式，就是首先子组件在自己的template里写一个坑，用标签《solt》《/solt> 然后，在子组件使用的时候，也就是写子组件标签时候，它的标签对里，一定要是
                                       子组件的标签对里的东西， 《test》XXXX《/test》 这个xxx就是标签对里的东西，这个标签对里可以用差值表达式写父元素的数据的，然后 这里的东西，全部，全部就是替代了本身的template里的solt位置的位置
                              具名插槽：这个就是上面的升级版，就是在这一个子组件里定义好几个solt的时候，加上名字 用属性name加   《solt name=“aaa”》《/solt> 《solt name=“bbb”》《/solt>  然后在这一个组件时候，它里面的template不是
                                       有三个位置等着被填嘛，这时候在这个组件标签里，你就要至少写三个标签了，标签上面也要写个属性，就是solt，然后它的值是template里的solt的哪个值，就是把这个标签放在对应位置
                                       就比如，如果我写了 《test》 《span solt=‘aaa“》我是span《/span>   <input solt="bbb" />  那么里面两个标签就会直接放在template里的对应的solt的位置了
                              然后如果说这个子组件写的时候标签里没有写任何东西，那么可以在template的solt标签里自己写，写的就是默认的东西，也就是没有数据来的时候就用这个自己的东西

               作用域插槽：这个呢，是子传父。首先呢在子组件里的template里一样的挖坑，但是挖坑的同时带上要传过去的数据，写法呢，就是在挖坑时候加上动态自定义属性，名字随便取，值就是要带过去的本地的子组件的数据 <div> <solt :aaa="mes(这是本身子组件里的data数据值)></solt>"
                                          这时候在写子组件标签的里面随便写一个标签，这个标签一般是用div了，然后在这个div里加个固定属性 solt-scope 值一般也是默认的props  这个值就是你前面挖坑时候写的哪个自定义属性还有值组成的对象
                                          然后这个时候，在这个div下面的所有东西才是代替坑里的内容，然后 在这个div下面就可以拿到props了，比如这时候我在这里搞一个事件，但是把事件处理函数搞在父组件了，就实现了子传父



vue-cli(脚手架)  ：这玩意就是个管理工具，是运行在node环境下的，安装时全局安装，npm i -s @vue/cli  

                 路由：hash模式 它的形式是这样的http://xxx.abc.com/#/xx。 有带#号，后面就是hash值的变化。改变后面的hash值，它不会向服务器发出请求，因此也就不会刷新页面。并且每次hash值发生改变的时候，会触发hashchange事件。因此我们可以通过监听该事件，来知道hash值发生了哪些变化。
                             window.addEventListener("hashchange" , ()=>{ location.hash })  这个路由的hash具体的值，是通过一个location对象里的hash属性得到的

                 路由的使用步骤：：还挺麻烦的。第一，首先在src下面整一个文件夹，叫ruoter 里面都是放路由的文件，然后再它里面再整个index.js文件作为路由的总入口，也就是说后面要用的所有路由，都由这个路由来导出去，然后还要
                                                  整一个routers 这里就是分别放一个个单独的路由文件，也就是到时候index.js导出的就是里面的路由
                                                  然后这个index写路由文件，包括routers里面的一个个单个路由写的步骤是差不多的，就拿里面一个个的路由来说，
                                                       首先导入必要的东西 就是vue跟vue-router  
                                                       import vue from "vue"  import Vuerouter  from 'vur-router'   然后把vuerouter引入到vue类中  Vue.use("Vuerouter")   
                                                       然后再引入组件，这个组件是下一步定义路由规则时候要用到的组件，import 组件名 from “@/views/”   这里的@就是知道src目录，不是src/  然后如果这个组件名字是js或者vue 那可以不写后缀名，如果是index 那整个名字都可以不写
                                                       然后就是定制路由了，其实这里可以定义好几个路由的规则， const routers=[ {path:/hello , component:组件名} , {}, ]  这里是可以写好几个路由的，所以这个文件也不能单纯地叫单路由文件。
                                                       然后再创建路由实例  const router=new Vuerouter({ routers : 路由的规则 })  这个地方的属性名字routers是定死的，不能变
                                                       最后再把这个实例给导出去  export default router

                                             第二：路由现在有了，现在那个src下面的main.js就是整个项目的入口，也就是它里面要用，还是先在里面把router的总的入口index.js引进了就行  import router from @/router/index 
                                                               这个main.js里是会创建一个vue实例的，然后，路由就挂在它里面就行了 跟前面什么data啊methos一样的， 名字是router：router

                                             第三：这时候路由不是也挂载了mian里面了嘛，因为main是程序的入口文件，这时候main里面写的vue实力的#app，也就是说白了就是vue管理的最大的那个div，不也是一个组件嘛，只不过这个组件就是src下的APP.Vue
                                                  也就是说，你这vue里写的任何东西，最后显示的不都是这个app.vue组件里的template嘛，然后在这个app。vue组件里的template里写个标签《router-view></router-view>
                                                  这里就会显示vue中写的router的内容了，如果不写，那你这路由里到时候给的东西展示不了啊，因为最终的展示是app。vue这里的template决定的

                  路由模式的切换：因为路由一般有两个模式，hash和历史模式，默认的是hash模式的，如果想要换，在配置生成实例的时候，配置一下，也就是在路由文件里 const route= new Vueroute（{ routes , mode:hash/history }） 如果换了模式，在服务端配置的时候也要注意跟着改的

                  声明式导航：导航导航的意思，就是说你要点去一个地方时候，你点的那个东西，就是导航，所以说，具体你点了这个导航，也就是去了一个地址后，这时候页面给你什么反馈还是你点去的那个路由来写决定的
                             这会儿再回来说这个声明式导航，它其实就是个vue自定义的组件（标签） 这个跟a标签很像，文字是写在标签对中间的 
                             《route-link to=“地址”  tar=“ li ”》点一下《/route-link》 这里的属性名 to的值就是目标地址  然后这个tar的值一般是个html的元素名，就是说指定这个导航到底是什么东西，它默认值是a标签，比如你要是写了li  这玩意就是个li标签的
                             《route-link :to={path：‘地址’}》  这是动态写法，这里面的属性名就是path  

                  编程时导航：就是字面意思，就是用代码写的，就跟之前的 window.history.href="" 基本上一模一样，所以它也是需要一个事件来触发的 写的时候语法
                             this.$router.push('地址')    this.#router.push( { path:"地址" ， query：{ name：‘aaa’ ，age：1 } } )  这是带参数的写法，而是这个参数形式就是get的，也就是直接在地址后面写的那个？name=aaa&age=1
                             this.$router.back()  :这个就是退回。。。。。这种导航方式有个小问题，就是你点了以后，不是不会刷新页面嘛，但是会有对应的组件变化是吧，如果这时候你再接着点，后台会报错，但是效果不影响，不解决也行，或者百度下，用原型重写下push方法就可以，其实就是catch一下错误

                  路由重定向：很简单，就是访问一个地址时候，我让他给转到另一个地址去了，这个配置想想也知道，就是在路由的配置里写的，因为路由的配置里写的就是所有不同访问的地址后，要给的组件或者处理
                              const router  =[ { path：‘访问的地址’ ， redirect：‘重新转到的地址’ } ，第二个路由..... ]     

                  路由嵌套：就是跟以前的node模板嵌套差不多，意思就是几个路由的页面有   部分一模一样的时候，把这一样的部分搞成父路由，子路由写在下面，具体是，先定义好父路由规则
                           const router =new Vuerouter（{
                              routers：[
                            这是父路由     {‘地址’ ， component：‘对应的组件’  ，   这里是先搞好父路由的东西，组件就是待会儿下面子路由公共的部分
                                             children[
                                                {path:'一个子路由地址' ， component：“组件”}，这是第一个子路由，记得写这个path时候，前面不能加/   这时候访问这个子路由，也就必须要带上上面的父路由地址往后写 嘛
                                                {path:"第二个子路由地址" ， component：‘组件“}  第二个
                                             ]
                                 } 
                              ]
                           }）
                           然后配置玩后，还要在父路由的组件里说明子路由的组件到时候放在父路由的哪个地方  在父路由的组件的template下 《router-view><router-view> 这个位置就是放到时候对应的子路由的组件内容的
                  
                  动态路由参数：这个跟node里面的那个一模一样，意思就是说在访问路由的时候，同时传递参数过去，这个一般指的就是get的方式，而且这个传参的方式不是get问号那个，是直接写在路由后面的 /id 这种方式
                              比如 http://aaa/:id  这个路由的意思是，你访问的时候，你的访问地址一定要是 http://aaa/111  其中这个111就是参数，然后如果对应的路由的组件要用到你传来的参数，也就是在组件的template里使用的话，就是
                              在template里的《script》标签里的 created函数里写  this.$route 获取到的就是路由对象，里面有这个参数id  
                              还有一种方式直接在template里直接用插值表达式式的方式获取，那么这时候就是直接的 {{$route.parse.id}}
                  
                  路由别名：就是把一个路由换个名字，然后访问时候访问别名就行，这个的定义就是在路由的定义规则的时候，加个name属性就行  const route=new route（{ path：“xxx” ，name：‘新名字’ }）
                           然后使用的时候，是在导航那里设置对应的名字就是，因为路由定义后，你如果不用导航，那就只能用浏览器里 输入这样的方式访问了，在导航那里设置时候，只能是声明式导航可以用
                           语法是  《route-link ：to={name：‘这里就是路由定义时候的别名’ ， }
		
	vuex：这玩意就是一个管理数据的，然后作用就是让各个组件之间的数据传用起来很方便，用法首先是下载，npm i -s Vuex    然后再scr下面有个store文件夹，在里面创建一个index.js文件，
		就是在里面写了，然后写什么呢，，，
		这是vue实例中的一个属性，啥意思呢，就是跟date啊，还有route啊这些玩意一样的，都是属性，所以写的话，格式跟route差不多，
		                        import Vue from 'vue'
                               import Vuex from 'vuex'
                              Vue.use(Vuex)
           	                  export default new Vuex.Store({ 
                                   state: {count: 0}      // state中存放的就是全局共享的数据
                              })   这是最基本写法，然后同样的，这玩意是属性，要写到项目根部的vue实例中，注意这里在写到根实例下的时候，跟route一样，也就是注册的时候，这个属性名一定只能是store，不能是其他的
		  然后所有其他组件想要用的时候，不用引入了，就是直接在自己使用的函数里写this.store.state.count   这既是拿到了
		      还有一种方式，就是其他组件可以一下子从这个里面拿多个数据，然后把这些多个数据放在自己本身组件里，然后就不用每次都this.store.state 的拿了。这个方法就是先要在本组件引入一个Vuex里的函数，，import {mapState} from 'vuex'  
      然后这个函数一定是只能在本组件的computed里面使用，而且使用规则固定：：computed：{   ...mapState(['想拿的数据1 ， 想拿数据2']) }    这里的写法是 固定的。 然后 拿到的这写数据，就是相当于放在了自己组件的data里面了，所以用法也是跟使用自己的data数据一模一样的

		然后是这个store里面的第二个属性：第一个是state 第二个是 state，  mutations：{ 方法1（ 参数1就是前面的state ， 参数2就是你要传的实参 ）{xxx } ，方法2（{}） }  这个属性里就是写方法的，这些方法就是用来修改前面的属性state的值得，这个里面的函数是只能用在同步代码里！！！！
                                       所以这里写的每个方法都是至少有一个参数的，
                                        这第一个参数就是state，第二个参数才是真正调用的时候要传的实参，这个然后用的时候，跟state差不多，也是两个方式，第一个直接用，就是哪个组件里要用，就直接写  this.$store.commit( 'mutations里面的方法名' ， 实参)    
                                    第二个方式跟前面逻辑一样的，一样哪个组件用，先在这个组件里引用vuex里的另一个函数import {mapMutations} from 'vuex'  然后用的时候，这个函数只能写在这个组件的methods里面，写法就是   ...mapMutations(['mutations里的函数名','reduce']),  然后用的时候就是把它当做methods
                                        里的函数用就行，函数名就是它里面的函数名

      然后是第三个属性：actions 这个跟上面那个区别就是这里是写异步代码的，就是这个属性里的方法内容可以写异步代码，然后它的语法跟上面基本上一样，作用只不过它里面的函数参数的第一个是整个store对象。然后使用的时候，也是第一种就是直接使用  this.$store.dispach('actions里的哪个方法名' ， 参数实参)
                     然后它一样的，也是还有第二个方式，也是借用了一个函数mapAction,也是先引用，写在组件的methods方法里  ...mapActions(['actions里的函数名', 实参])

      然后第四个属性：getters：它就是单纯的对state里面的数据进行加工处理的，有点像vue中的计算属性，语法就是 getters：{ 方法1:（参数就一个，就是state）=>{ returnxxx } } 这个函数一般是有return返回值的
                     然后哪个组件使用它的话一样，第一个方法就是直接 this.$store.geeters.方法名
                     第二个方式一样的，引入mapGetters 然后再使用它的组件的计算属性中写 computed：{...mapGetters（[方法名1 ， 方法名2]）}  然后再这个组件用的时候，就是跟计算属性用法一抹一眼，记得计算属性里方法使用时候不能加（）

      然后第五个属性：module：{模块1 ， 模块2}     这个是有注意点的。首先这个属性的意思就是把整个store模块化了，里面的值就是引入进来的不同人写的store，然后这个一个个的模块文件一般是放在store文件夹下的modules里面，每个模块写的东西，
                                                格式就是跟这个一模一样的，只不过最多只要写前面四个就行了。记得要导出，然后这个总的模块用的时候，要首先再加一个属性namespaced 值是TRUE   同时还要加上module这个属性，值得话，就是引入进来时的每个模块的名字 例如modules：{属性名1：空间1 ，xxx}
                                                 然后用了模块化后，到时候用的时候，就要区别下用的是哪个模块下的东西了，具体的每个用法上的改变，如下
                                                 - state
                                                 - this形式：this.$store.state.空间名.xxxx
                                                 - map系列：...mapSate(空间名,[xxxx,yyyy,zzzz...])
                                                 - mutations
                                                 - this形式：this.$store.commit("空间名/方法名", "参数");
                                                 - map系列：...mapMutations("空间名",["方法名",...]),
                                                 - actions
                                                 - this形式：this.$store.dispatch("空间名/方法名", "参数");
                                                 - map系列：...mapActions("空间名",["方法名",...]),
                                                 - getters
                                                 - this形式：this.$store.getters["空间名/属性名"]
                                                 - map形式：...mapActions("空间名", ["属性名",....]),
                                                 这里所有的空间名，就是指的每个小模块引进了来的时候，modules里面写的属性名，只不过一般都是写的属性名跟空间名一样


      路由守卫：意思就是，在访问一个路由的时候，在去之前做的一些处理 ， 最常用的一个场景就是比如，在一个应用的个人信息页面时候，这个页面里的其他小路由，比如个人信息页面里的余额路由，那点那个路由的时候，一定要在登录了的情况下
               才可以点的进去，这时候就是可以用路由守卫， 然后它有全局的路由和组件的用法，这两个的区别主要是在写的位置不同，如果是全局的话，就是所有的路由都要走，全局路由一般是写在那个总路由文件（也就是这个路由文件最终挂在main.js的那个）里面，
               具体的位置是在总路由写完后，在它下面写，比如总路由写的是  const router= new VueRoute（{}）。。  全局路由守卫就写在它后面。 全局路由只有两个钩子函数 
                   router.beforEach(to ， form ，next){}  所有的路由走之前都要走这个，to就是目标路由地址，from就是本身的路由地址，next就是说处理完后继续走，不然路由都不走了
                  router.afterEach(to ， form ){}  就是路由走了以后的处理 这时候路由都走了，所以不用参数next了

               局部路由，这是写在每个路由对应的组件中，然后写的位置就是跟生命周期一样，正常直接写就行，这时候它有四个方法：
                        beForeRouteEnter(to , from ,next){}  路由还没有到的时候，这时候这里函数里是拿不到thisvue实例的
                        beforeRouteUpdata（to, from ,next）{} 这是路由被复用时候，意思就是说比如这个路由可以带不同参数，/xxx/:id ,这时候路由是前面的部分对吧，但是别人访问时候，后面带的参数不同，那页面也不一样，这时候这个函数就触发了
                        beforeRouteLeave（to，from）{}离开这个路由时候触发


vue项目过程：  1、安装所有必要的插件  vue  vue-cli（安装这个时候会选择安装好vue-router） 然后创建项目：create 项目名字
                              创建的文件中，public文件夹：一般放的是整个项目一进去的页面，里面也会放这个页面所需要的静态资源，这个页面也是项目的根Vue挂载的#app 就是这个页面里的div
                                  src：assets：这是是放静态文件的，一般再里面再分为几个文件夹，用来放后续所需要的静态文件、图片啊，引入外用的字体的css表、视频啊等等
                                       components：这是里功能组件，就是这里的组件是可以复用的，比如一个项目中的好几页的首位内容都一样，这时候的首位内容就可以做当组件放在这，
                                                   还有可复用的组件，比如要是好几个页面都要用到input框啊、导航栏啊、甚至弹窗卡片，总是就是好多页面都会用的组件就放这儿
                                       vuews:这个就是放项目中大的页面的，就是比如项目分为登录页，首页、咨询页等等这些路由的页面。或者说就是不能被复用的页面
                                       router：这是就是放路由的地方，一般这里会写一个总的路由文件index.js 然后再写好多个文件夹，分别是不同的主页面，差不多就是views里每个页面下的所用到的路由
                                       store：这是放store数据的地方，也就是整个项目中哪里都可以用，哪里用，引入下就行。记住，因为这里也会用到模块化，所以一般跟路由一样，在外面写个index.js这个是总的store，
                                             在它里面会开始 nameSpace：TRUE   然后再搞几个不同的文件夹，它们里面再分别写（这就相当于不同的人共同合作时候，每个人用的数据以及数据处理做成独立的，这样就算有两个人用的数据名字一样都没事）
                                       mixins 、filters 、 director 这些就是单纯的意思
                                       main.js:这个文件就是vue项目一进来就是会执行这个文件，
                                       App.vue：这个就是main.js这个文件里面根vue实例所挂载的组件，也叫根组件

               2、启动项目:在项目文件夹下 npm run serve  具体过程如下 

               3、走main.js   1）首先就是找src下面的main.js文件，它里面的有个跟vue实例 实例里面后续要用到的route啊，store啊，都是要在这个地方引进来的，然后再把它们放在vue实例里，也就是注册这些东西。这也就是后续这些东西的分模块里只要用到this，指的 就是这个vue实例
                              2）然后还有一点就是如果想要在项目中定义一些方法，让他在后续的各个模块或者js文件里使用，可以把这个方法写在这个文件里，就是在这个文件下 用vue.prototype.$属性名 = 你自己的方法甚至数据.这样在后续的使用中，就不用再import了。放在这是因为这个
                                 是根组件，这个组件是不会被销毁的，如果在其他组件里引用vue然后再写到原型上面，其他组件很容易被销毁（也就是切换路由就销毁了对应组件）
                              3）这个跟实例，它下面肯定也要挂一个组件，也就是APP.vue 

               4、走到APP.vue  1）这里就是根实例对应的组件，也就是说，它里面的template就是整个项目的展示区，而整个项目的展示的东西是由后面的路由对应的模块展示的，所以这里肯定要有个路由展示的标签<router-view/>这标签的意思就是说路由对应的组件展示区。
                               2 ）这里还一般放些组件，就是整个项目绝大部分的页面都有的共同页，比如页面的最顶和最底，整个项目中绝大部分页面都有的话，那把那些组件页可以放在这里，然后再搞一个变量控制它显示不显示，这变量肯定得要所有组件都可以控制，也就是放在store里，
                                   然后小部分页面如果不需要显示的话，那到时候 就在那些小部分页面路由对应的路由设置路由守卫或者组件生命周期函数 来把那个变量关了

               5、走到了各个分部了，1）首先是封装：
                                      就是有些方法，在整个项目中经常用到，这时候就可以搞封装，特别是比如发送请求，这时候最好就是先把它封装好，可以在根部vue实例中用原型挂，也可以把它直接导出来，哪个模块用再import引用
                                      发送请求方式axios：一般在所有的发送请求中，都要带jwt验真 这时候要用到一个东西叫请求拦截器 语法是：  axios.interceptors.request.use((cfg) => {}） 就是在这个里面把jwt或者需要带到后端的东西在这里设置
                                       同样的也有个响应拦截器，就是给响应回来之前做一个设置，最简单的就是如果响应的数据格式不对，就可以在这里先处理下数据  axios.interceptors.response.use((ret) => {
                                  2)所有的方法封装后，这时候就要走程序了，首先就是要点击，这时候走就要走路由了，就是点啥，我要给你对应的组件来显示对应的内容了，
                                    路由：都在router文件夹下，这文件夹下有个总路由，是js文件。就是所有模块路由的集合。这里面写的路由规则一般都是访问根目录时候，或者访问地址错误的时候，然后同时把后续根据页面划分的其他小路由模块都引入、加进来
                                          在写各个小路由模块时候，记得会写到路由嵌套的，然后路由后就是去找对应的路由模块的组件去了。 也就最开始找路由显示的组件该显示在哪，也就是找《router-view》标签，再找路由对应的组件，把那个组件显示在这个标签里
                                    组件：就是每个路由都要显示内容，这个内容就是路由对应的组件来显示。这里首先就是在<template>里的东西就是最后显示的东西
                                          组件里的script标签里就是写数据处理，比如路由守卫、还要前面提到的要改变那个控制所有页面都有的组件要不要显示在本组件的变量
                                    store：这里就是储存所有的公共的数据的地方，就是有些数据如果是所有组件后续都可能用到的话，就会放这里，这里同样式用模块化，就是先搞一个总的js文件，这里引入后面所有的store的模块，这个最后也还是要挂载
                                          在根实例下的，所以，它里面函数的this，也就是指的根vue实例  store是vueX里面的东西，所以在那个总store文件里，要声明Vue.ues(vuex) 然后再new veux.store，再导出

               项目中注意：              
                  1、 vue项目中的根组件 App.vue，它是不会被销毁的，就是说，它的created mounted这些只会再项目开始时候执行一下，后续只要项目没有关，怎么都不会执行了但是里面如果写了监听事件，那是可以正常一直监听的
                  2、项目中只要用到其他插件，比如vuex、vue-router vant 这些不仅要import，还要Vue.use(vuex) 注册                             
                                                         
                                                                        
-------------------------------------------vue细节问题--------------------

在组件中，如果要引入css文件，语法是直接import     import‘路径.css’  

在vue中，可以是用插件懒加载 安装vue-lazyload  然后再引入、配置，配置就一步，就是指定到时候懒加载时候用啥照片替换原照片 
                  import VueLazyload from 'vue-lazyload'
                  Vue.use(VueLazyload, {
                      loading: "懒加载的图片	",
                   });
          最后再使用这个插件自带的指令 v-lazy 代替掉原来图片img标签的src  值不变哈，还是最后要展示的图   <img v-lazy="最后该显示的图片"/>

vue在使用中，经常会用到：key=‘唯一值’    比如在循环时候，就会在被循环的标签里加一个这，这个的主要思想就是，因为：key是动态绑定的，根据diff算法，只要这个值变了，就会重新渲染，所以主要作用就是让vue重新渲染，这在以后的项目中经常用到，用来处理一些bug


