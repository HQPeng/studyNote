    js内部错误类型：  语法错误：syntaxError 
                    类型错误： typeError  
                    引用错误： ReferenceError
                    范围错误：  RangError

    前端性能优化：  Vue中，在对于以后还需要显示的元素，用v-show代替v-if
                   vue中，计算属性具有缓存机制，在数据不变的时候，计算规则是一定的时候，计算属性的效率远大于一般方法
                   在webpack打包时候，使用css抽取插件，因为默认的css在使用它的打包loader时候，是把css数据动态添加到html的head里面去的，消耗内存

    js异常error：有两个情况，一个是捕获异常，就是代码可能有异常，捕获一下并处理 语法  try{ 可能有 异常的代码}  catch（error）{ 这是捕获到异常后的处理方式}
                            其中参数error就是异常信息，它是一个对象，有两个属性，一个是message 显示具体信息，一个是stack，显示基本信息，就是常见的再console.log里错误显示的内容

   ！！！！ 队列：js执行代码顺序：因为js引擎是单线执行的，也就是在一个时间点只能做一件事 先是执行所有同步代码，同步代码中如果有回调函数，也就是有异步代码时候，
                               会把异步代码放在两个队列中，分别为宏队列跟微队列，其中微队列常见的就只有promise ，其他的常见异步代码定时器、dom操作的异步、Ajax
                               这些都是放在宏队列里面去了，然后等到所有的同步代码执行完成后，就会执行队列，执行时候是----执行宏队列，但是 在每次执行宏任务时候，都要先
                               把微队列里面所有的任务执行完，才会执行这个宏认为，记住，每次执行一个红任务时候，都要这样！！！！！！！！！！！！

   垃圾回收机制、内存：js中内存分配和回收是自动完成的，内存不被使用时候，就会垃圾回收器回收
                     没有用到的内存，但是没有被回收，叫内存泄漏
                     !!!!全局变量一般不会被回收，局部变量用完后，，没有人用了，会自动回收，这也是为什么尽量避免使用全局变量原因
                     垃圾回收器的算法：引用计数法，就是内存每被指定一次，就加1，每被放弃一次（比如定义的变量后面又重新定义了这个变量）那就减1，到0的时候，就回收，现在基本不用了
                                      标记清除发：现在用的主要方法，就是从根部（全局对象）开始扫描，凡是能从根部扫描到的内存空间，就是认为是需要的，如果从根部进不去你这内存空间，就回收
                                                 举个例子：就是比如一个函数  function fn（）{
                                                                                            let o1{} ， let o2={}
                                                                                            o1.a=o2 ,o2.a=o1
                                                                                                 }
                        这代码执行时候，如果按照引用计数法，函数执行完，因为是局部变量，刚开始定义的o1和o2的存地址的堆空间已经没了，但是因为他俩又互指，所以栈空间不能被清楚，这就内存泄漏了
                                      如果按照标记清除法，函数执行完，一样的，o1和o2 的堆空间没了，这时候扫描，是扫不进去栈里面这两互指的空间的，因为刚开始，根部也就是全局，就是通过o1指向堆，堆再指向栈的
                                      现在全局跟堆的指向没得了，就扫不进去栈里了，就被噶了
   
   解构赋值的高阶用法：让函数传参更加容易  function fn（{name , age=29 }）{ console.log(name ,age) }
                                        fn({name:test })  这段代码的意思就是，函数定义时候，穿的参数需要是个对象，然后而且最好你到时候调用这个函数时候穿的实参
                                                          对象里要有name和age  如果没有你的实参对象里没有这个成员，那么函数运行时候就会用声明时用写形参时候默认写的那个值 数组也是一个道理

   cookie:这个东西啊，正常情况下其实是服务器端给的，就是你第一次访问服务器时候，是没有cookie的，然后服务器给你返回数据时候，它在里面写了cookie的，你第二次访问时候，服务器就会收到cookie的

   fetch:跟Ajax差不多，也是html5内置的 是个promise  但是是直接用的，不用new 语法  fetch（http://xxx/?id=123&age=23 ）.then(){}  ：  默认是get请求，第二个对象参数是个配置，如果要发post，那要配置了
                                                                                        或者
                                                                                     fetch（url ， {
                                                                                            method：post，
                                                                                            body：   参数  "uname=lisi&pwd=123"
                                                                                            headers{
                                                                                                “Content-type”:"application/x-wwww-form-urlencode"
                                                                                            }
                                                                                    } ）.then(参数)  这个参数就是成功后，后端返回的数据
                                                                                        .catch（error） 这个参数就是错误信息
                                                                            默认是get请求，第二个对象参数是个配置，如果要发post，那要配置了

    axiox：  axios.get('/get_data?id=10010').then(ret => console.log(ret.data))   
             axios.get('/get_data',{
                                params: {
                                    id: 10010,
                                    name: 'zhangsan',
                                    age: 26
                                }
                }).then(ret => console.log(ret.data))

                总的方式写
            axios({
                method: 'post',
                url: 'set_data',
                timeout: 1000,   // 超时时间：如果请求花的时候超过了预设时间，则请求取消
                headers: {'头信息名': '头信息值'},
                data: "username=zhangsan&type=2"
            }).then(ret => { })

        axios它有   全局配置写法，也就是说以后的项目中，访问的地址的地址一般都是一个，只不过url不一样罢了，所以可以把地址全局配置，然后以后就可以在具体的每个axios里写
                    url部分就行了  axios.defaults.baseURL = 'http://localhost/app'【设置默认地址】   


在node中的导入，如果是导入的东西是插件，就是直接要写 import xxx from“xxx”   如果导入的是插件里的类、函数等等这些，就是要用大括号，import {a，b，c} from “xxx”