# 一、错误、报错

- `js`内部错误类型  语法错误：`syntaxError` 、 类型错误：` typeError`  、引用错误：` ReferenceError`、范围错误：  `RangError`

- `js`异常`erro`r：

  > ​	一个是捕获异常，就是代码可能有异常，捕获一下并处理 语法  try{ 可能有 异常的代码}  catch（error）{ 这是捕获到异常后的处理方式}，其中参数error就是异常信息，它是一个对象，有两个属性，一个是message 显示具体信息，一个是stack，显示基本信息，就是常见的再`console.log`里错误显示的内容

# 二、性能优化

- `vue`中
  -  `Vue`中，在对于以后还需要显示的元素，用v-show代替v-if
  - 计算属性具有缓存机制，在数据不变的时候，计算规则是一定的时候，计算属性的效率远大于一般方法
- 在`webpack`打包时候，
  - 使用`css`抽取插件，因为默认的`css`在使用它的打包loader时候，是把`css`数据动态添加到`html的head`里面去的，消耗内存
  - 使用import引入资源时候，，使用懒加载和预加载，使得资源在被使用时候，或者空闲时候去加载。

# 三、队列



- **`js`执行代码顺序**：

  > 因为js引擎是单线执行的，也就是在一个时间点只能做一件事 先是执行所有同步代码，同步代码中如果有回调函数，也就是有异步代码时候，会把异步代码放在两个队列中，分别为宏队列跟微队列，其中微队列常见的就只有promise ，其他的常见异步代码定时器、dom操作的异步、Ajax
  > 这些都是放在宏队列里面去了，然后等到所有的同步代码执行完成后，就会执行队列，执行时候是----执行宏队列，但是 在每次执行宏任务时候，都要先把微队列里面所有的任务执行完，才会执行这个宏认为，记住，每次执行一个红任务时候，都要这样！！！！！！！！！！！！

# 四、垃圾回收机制

> `js`中内存分配和回收是自动完成的，内存不被使用时候，就会垃圾回收器回收
>
> 没有用到的内存，但是没有被回收，叫内存泄漏
>
> 全局变量一般不会被回收，局部变量用完后，，没有人用了，会自动回收，这也是为什么尽量避免使用全局变量原因

-   垃圾回收器的算法

  - 引用计数法，就是内存每被指定一次，就加1，每被放弃一次（比如定义的变量后面又重新定义了这个变量）那就减1，到0的时候，就回收，现在基本不用了

  - 标记清除发：现在用的主要方法，就是从根部（全局对象）开始扫描，凡是能从根部扫描到的内存空间，就是认为是需要的，如果从根部进不去你这内存空间，就回收   

    ~~~js
    function fn（）{
      let o1={} ， let o2={}
      o1.a=o2 ,o2.a=o1
    }
    ~~~

    这代码执行时候，如果按照引用计数法，函数执行完，因为是局部变量，刚开始定义的o1和o2的存地址的堆空间已经没了，但是因为他俩又互指，所以栈空间不能被清楚，这就内存泄漏了
    如果按照标记清除法，函数执行完，一样的，o1和o2 的堆空间没了，这时候扫描，是扫不进去栈里面这两互指的空间的，因为             刚开始，根部也就是全局，就是通过o1指向堆，堆再指向栈的 现在全局跟堆的指向没得了，就扫不进去栈里了，就被噶了

  # cookie

- cookie:这个东西啊，正常情况下其实是服务器端给的，就是你第一次访问服务器时候，是没有cookie的，然后服务器给你返回数据时候，它在里面写了cookie的，你第二次访问时候，服务器就会收到cookie的

# 五、请求方法(feacth、axsio等)

- **！！！Ajax、axsio是对xhr的封装、fetch是跟xhr同级别的。**

- Ajax：

  ~~~js
  请求
  const xhr =new XMLHttpRequest() //创建一个请求实例
  xhr.open(mehtod , url , async)    //配置请求信息 
  //method：请求的类型；GET 或 POST,
  //url：文件在服务器上的位置,
  //async：true（异步）或 false（同步） 
  
  xhr.open("POST","test.html",true);
  xhr.setRequestHeader("Content-type","application/x-www-form-urlencoded") // 注意：post请求一定要设置请求头的格式内容
  xhr.send("fname=Henry&lname=Ford"); //post请求参数放在send里面，即请求体
  
  响应：
  xhr.onreadystatechange=function() {       //响应方法
       	if (xhr.readyState==4 &&xhr.status==200) {
       		document.getElementById("myDiv").innerHTML=xhr.responseText; //xhr.responseXML：xml格式响应
       	}
       }
  xhr.onload=function(){}  //正确响应回调
  xhr.onerror=function(){}  //错误响应回调
  
  取消请求
  xhr.abort() 
  
  
  
  ~~~

  

- **Axios**：一种对Ajax的封装，**可以有拦截器功能**

  ~~~js
  axiox：  const axios=axios.create({url:'xxx' , timeout:3000 , headers:{xxx}})
  
  				axios.get('/get_data?id=10010').then(ret => console.log(ret.data))   
           axios.get('/get_data',{
                              params: {
                                  id: 10010,
                                  name: 'zhangsan',
                                  age: 26
                              }
              }).then(ret => console.log(ret.data))
  
              总的方式写
          axios({
              method: 'post',
              url: 'set_data',
              timeout: 1000,   // 超时时间：如果请求花的时候超过了预设时间，则请求取消
              headers: {'头信息名': '头信息值'},
              data: "username=zhangsan&type=2"
          }).then(ret => { })
  
      axios它有   全局配置写法，也就是说以后的项目中，访问的地址的地址一般都是一个，只不过url不一样罢了，所以可以把地址全局配置，然后以后就可以在具体的每个axios里写
                  url部分就行了  axios.defaults.baseURL = 'http://localhost/app'【设置默认地址】 
                  
  axios的请求拦截器：
  		
        axiosInstance.interceptors.request.use(
          (config) => {
            // 在请求拦截器中不要返回 reject 的 Promise，这不会取消请求,而是让请求一发出去后就走了请求的catch程序
            // 这里可以添加认证信息或修改请求头
            return config;
          },
          (error) => {
            // 如果请求拦截器中发生错误，会进入这里
            return Promise.reject(error);
          }
        );
  
  axios的响应拦截器
  		axiosInstance.interceptors.response.use(
    (response) => {
      // 在响应返回前，可以在response中进行修改或添加一些内容
      // 例如，处理响应数据
      console.log('成功的响应拦截器:', response);
      return response;
    },
    (error) => {
      // 如果响应返回错误，可以在这里处理错误
      console.error('响应拦截器错误:', error);
      return Promise.reject(error);
    }
  );
  
  取消请求（前端的）：
       1、 从axios库中导入一个CancelToken的属性
       	import {CancelToken} from 'axiso'
  
  		 2、利用属性中的source方法创建一个取消请求的资源对象
       	const source=CancelToken.source()
        
       3、把source对象中的token放在这次请求的CancelToken属性上面，这表示，这个请求跟这个CancelToken的这次token关联起来了
       		不能在前面就先 source.token好，如果那样，就表示先生成了固定的token，那么后续所有的请求都是用的这一个token了，那不行
  
            axios.get('https://api.example.com/data', {
              cancelToken: source.token,
            })
              .then((response) => {
              // 处理成功的响应
              console.log(response.data);
            })
              .catch((error) => {
              if (axios.isCancel(error)) {   //这里的 axios.isCancel(error) 函数是用来确认请求错误是不是因为请求导致的，
                														  //如果是,那么这个函就返回true，里面的参数就是调用取消请求时候的数据
                console.log('请求已取消:', error.message);  .//也就是下面调用取消请求时候传入的数据
              } else {
                // 处理其他请求错误
                console.error(error);
              }
            });
  				// 在某个适当的地方取消请求
            source.cancel('取消请求的原因');
  
  取消请求（后端的）：
  跟下面的fetch一模一样，一点都没变
  ~~~

  

-  **fetch**跟Ajax差不多，也是html5内置的 是个promise  但是是直接用的，不用new 语法  fetch（http://xxx/?id=123&age=23 ）.then(){}  ：  默认是get请求，第二个对象参数是个配置，如果要发post，那要配置了

  ~~~js
  fetch（url ， {
    method：post，
    body：   参数  "uname=lisi&pwd=123"
    headers{
      “Content-type”:"application/x-wwww-form-urlencode"
    }
  } ）.then(参数)  这个参数就是成功后，后端返回的数据
    .catch（error） 这个参数就是错误信息
    
  取消fetch请求
  const controller=new AboutController()  //定义一个控制器
  const single=controller.signal				//拿出来控制器里的signal值
  fetch(url , {single}).then()          //把这signal值放在哪个fetch的第二个参数，就表示控制器跟这个请求连接起来了,注意是对象形式
  controller.abort()//调用这个方法名，就表示跟其关联的fetch就被取消了
  ~~~

  



#  六、路由模式区别

> - 哈希路由使用哈希标识符来管理路由，不需要服务器配置，但URL不够美观。
> - 浏览器路由使用HTML5历史API来管理路由，URL更友好，但需要服务器配置支持。

# 七、预解析

- 预解析：主要是使变量得到了提升。预解析阶段时候，是会把定义的变量做了解析，也就是让让这个变量提升到了当前作用域的顶部，所以在代码执行到这个变量时候，如果这个变量之前没有定义，但是在之后定义了，那会显示的是undefined，而不是报错，因为执行时候可以拿到这个变量（就是因为预解析时候把这个变量顶到作用域顶部了）如果拿都拿不到这个变量，才会是报错

- 作用域规定了：

  - 变量定义机制：定义在哪个作用域下就是那个作用域的私有变量，只能在当前或者其子级作用域使用
  - 变量赋值机制：先在当前作用域里查找赋值，如果没有，就向上级作用域里找
  - 变量使用机制：同上

  - 数据类型赋值：基本数据类型赋值就是正常理解，复杂数据类型赋值动的其实是地址，具体的内容其实就一个，例如  var a1={a:1 ，b:2}   var a2=a1  此时如果a1.a=3  a2.a也是3
    函数参数的赋值也是这样，如果一个函数在运行时候，里面的函数调用了外面的复杂数据类型，并且改动了，这时候在外面再用的时候，就是也会跟着修改的

# 八、CommonJS和ECMAScript

~~~js
导入、导出方式
//commonJs中
require（././.js）       //导入，不可以导入ES模块
module.exports=someData //默认导出或者是导出模块
exports.someDate=someDate//根据需要导出

//ESmodule中
import moduleA from 'module' //导入ESmodule模块
import moduleA as Testa from 'xx' //可以导入common模块进来，并把它另起名字。
import {A ， B} from 'xxx'  //导入common模块中的具体东西，因为common中，导出的一般都是对象类型

//import动态加载
import(.././).then(module){} //动态加载
export default someDate    //默认导出的东西
export const=xxx           //根据需要指定导出的内容



运行时加载和静态加载
CommonJS是在运行时加载的，所以只有在运行时候才可以确定模块之间的依赖
ESmodule是在静态时候加载，在代码构建的时候就已经确定了模块间加载关系，所以它的引入要在代码最开始部分就被引入好

模块可修改性
require引入是可修改的，引入了模块后，如果修改了里面内容，原模块就会修改
import是不可修改的，引入了模块后，根本不会关原模块任何关系

import引入缓存问题
如果第一次被引用后，后面再次引用同样的文件名，会走缓存，如果不想走缓存，就在第二次引入时候加query字符，让第二次引入的地址跟第一次不一样
A export default a=1
import A from A
import A1 from A //第二次引入A
A.a+1 ：//2
A1.a  //这时候，值是4  因为A和A1是同一个地址，或者说A1 拿的是A的缓存

import A1 fromA？aaa=1//随便加上一点query字符串，做不同的标识就行
A.a+1 //2
A1.a//1 这时候就还是1

~~~

# 九、浏览器渲染（微队列等）

> 进程：一个进程就是一块内存空间，一个程序至少需要一个进程，进程的设计目的就是让不同的程序之间是独立的，因为进程之间是基本上独立的

> 线程：一个执行进程的人。不同的线程执行不同的任务一样。一个进程可以有好几个线程，但是会有一个总线程，其他的都是它的子线程，这个主线程挂了，其他的子线程也挂了

- 浏览器是一个多进程的。它工作时候，是有好几个进程的，主要是包括浏览器进程、网络进程、渲染进程
  - 浏览器进程：主要负责浏览器的界面展示，比如浏览器的顶部工具、书签这些浏览器的东西，不是浏览器的内容部分
  - 网络进程：跟网络相关的
  - 渲染进程：会开启一个主线程，就是主要渲染内容的了，包括css js html代码。每个标签页是一个独立的渲染进程，互不影响
    - 渲染主线程工作：解析css、js、计算样式、每秒把页面画60次（fps）、执行js代码、事件处理函数、计时器回调等
    - 问题？为什么渲染主线程不用多线程来完成它的大量工作？？

- 渲染主线程的执行js代码过程就是【执行消息队列（事件循环）】里面的任务，同步任务就是正常放在消息队里里，等着主线程拿来执行，如果遇到异步函数，就会丢给对应的计时线程，主线程继续执行消息队里任务。如果计时线程结束了，就把任务放到消息队里的末尾。直到主线程执行到它

- 但是消息队列不是说只有一个，是可以有很多个的，也就是说，有很多个队列等着主线程去执行，具体主线程下一次会去执行哪个队列里的任务，这看浏览器自己决定。但是有个队列叫做【微队列】，主线程一定会去先执行微队列里面所有任务，才会继续执行其他队列里的任务

- **把任务添加到微任务的方法 `Promise.resovle.then(function(){xxx}) `:把函数里的代码添加到微任务里**

- js的执行会阻塞渲染的：因为主线程是同步的，js的执行跟页面的渲染是两个任务的，不是同一件事

  ~~~js
  document.body.textContene='内容'   //这是执行js代码任务，而且还产生了一个新的渲染任务，两个任务
  console.log(2)    //这是执行js代码。其实这个代码先执行的，然后上面的渲染任务其实是在这个任务之后的
  
  如果是执行一个js代码很费事的情况里，就可以很明显看得出来js的阻塞效果
  
  document.body.textContene='内容'    //这里同样会生成一个渲染任务，这个任务会被放在消息队列的末尾的，继续执行后面程序
  for（xxx）:这是一个很长很费事的for循环  //这里执行了一段时间
  所以最终的效果就是，页面得要过一段时间才可以看的到‘内容’
  ~~~

# 十、属性描述符

- 一个对象，它的每个属性，都是有一个属性描述符的，这个描述符规定了这个属性的特性，**这个描述符在写的时候，如果有就是对有的属性做属性描述，如果没有这个属性，就是定义了一个新的属性**

  ~~~jsx
  const obj1={
  	a:1,
    b:2
  }
  
  Object.definePropety(obj1 , 'c' , {  //这里就相当于给这个obj1里面添加一个新属性c
  	value:'3',         //属性的值
    writable:true,    //是否可重新赋值
    enumerable:true, //是否可被遍历
    configurable:false //这个属性的属性描述符本身是否可被修改，就是定义是否后面还可以再改这个属性描述符
    get:(){},         //获取这个属性时候执行方法，方法里返回的是什么，就是获取得到的就是什么
    set:(val){}			//设置这个属性的值的时候会调用这个方法，这个方法的参数就是设置时候想把这个属性设置成的值， 具体能不能设置成，看这个方法的执行
  })
  
  获取到一个属性的属性描述符信息的方法
  const mes=Object.getOwnPropertyDescriptor(obj1 , 'a')  //获取到obj1这个对象里的属性a的属性描述符
  ~~~

  

# 十一、hash和history路由模式模式

> 因为在单页面系统的开发中（一个html页面），整个项目只有一个html物理文件，但是通过路由系统，可以实现将项目的组件跟url地址进行绑定。在切换页面的时候，既要让url地址发生变化，又不可以触发html物理文件的重新加载，，所以route不可以使用常规的超链接方式，就提供了两种页面的加载和跳转方式

- hash模式：一种纯静态的方式，视觉上有#的显示，不美观。它是借助锚点配合onhashChange事件，一但url发生变化，执行响应的函数操作Dom的对象的切换。缺点就是不合适于分布式微前端
- history模式：视觉上没有# ，它是利用history对象中的pushstate重写了url路径，但是重写的路径下不包括html物理文件的访问地址，这会导致，如果服务器没有配置的话，刷新页面发送请求，是回报找不到资源的错误



# 高级回答面试题

## 阐述事件循环：

事件循环又叫消息队列，是浏览器渲染主线程的工作方式

根据Chrome的源码，会开启一个不会结束的for循环，每次循环从消息队列中拿到一个任务执行，其他的线程只要在合适的时候往消息队列末尾添加任务即可，

以前消息队列分为宏队列和微队列，但是现在改成是每个任务有着不同的任务类型，同类的任务必须在同一个队列，不同任务可以在不同的队列，不同任务队列之间有优先级，在每次的循环中，浏览器自行决定拿哪个队列里的任务，但是如果微队列中有任务，必须是先拿微队列中的任务

## 如何理解js的异步：

- 因为js是单线程语言（因为浏览器的渲染主线程是单线程的），所以渲染主线程是执行完本线程的主任务后，再从消息队列里顺序的拿任务去执行。如果遇到计时器、网络、事件监听这类情况时候，如果采用同步执行，会造成浏览器的渲染主线程阻塞。页面无法更新，卡死

  所以采用了异步的处理方式，也就是把遇到这写情况后，把这些任务交给其他线程处理，继续执行本身的主线程上的任务，等到其他线程完成后，**将事先传递的回调函数包装成任务放在消息队列的末尾**，等到主线程调度

## 浏览器是如何渲染的

- 当浏览器的网络线程收到一个html文档后，会产生一个渲染任务，并把它传递到渲染主线程的消息队列中，在事件循环的作用下，渲染主线程拿到这个渲染任务，进行渲染

  

- 渲染的根本原理就是得到每个像素点的颜色，具体过程如下顺序，依次进行

  - 解析html（包括css、js）

    - html解析到**link**的位置时候，也就是css时候，此时的css还没有下载解析好，主线程不会等待的，继续执行后面的，因为下载和解析css代码是在预解析线程中完成的，这就是css不会阻塞渲染的根本原因

      如果解析到《script》标签，也就是js的时候，主线程就一定要停下来，等待js解析完成，因为js有可能会改变前面已经解析好的DOM树，这就是js会阻塞渲染的根本原因

      解析完成后，就形成了dom树和CSSom树，搞出来这两个树的根本原因就是为了给后面的使用

  - 样式计算
    - 主线程会遍历得到的DOM树，依次在每个节点中，计算出它的最终样式，称之为CommputedStyle（浏览器的f12里可以看到），这个过程中，会有很多的预设值变成绝对值，比如颜色会最终变成rgb（255,5,1），相对单位变成绝对单位，比如em变成px，完成后，得到一个带有样式的DOM树  **常用的getCommputedStyle，就是获取的这个最终样式**
  - 布局：
    - 布局阶段会依次遍历DOM树，计算每个节点的【几何信息】，包括宽高、相对包含块的位置
    - 大部分的时候，DOM树和布局树不是一一对应的，比如display：node，它表示没有任何的布局信息，不会生成到布局树上面，又比如使用了伪元素：：before，虽然DOM树上面没有这些信息，，但是它们拥有几何信息，会生成在布局树上面，还有匿名行盒，匿名块盒.
    - 分层：浏览器的所有画面都是渲染出来的，如果每次画面一点小变化，就要重新画整个页面，太不划算，就有了分层效果，具体分几层，怎么分，是浏览器自己决定的。即后面如果哪些地方需要重新绘制，就重新绘制该层级就行。滚动条、堆叠上下文等等这些有可能会影响浏览器的分层

  - 绘制：生成绘制指令集 ，进行绘制

  - 分块：

    - 以上的都是在渲染主线程上面进行的，从分块开始，就是其他线程继续执行了。
    - 主线程将绘制信息交给合成线程，合成线程将每个图层画成不同的块，再从线程池里取出多个线程完成分块工作

  - 光栅化：合成线程将信息交给GPU线程，提高光栅化的速度，优先处理靠近视口的块，光栅化的结果就是一块块的位图

  - 画:合成线程拿到每个层，每个块的位图信息后，会生成一个个的指引信息，指引信息会标记出应该画在屏幕哪个位置，也会考虑变形，缩放等等，**这就是为什么transform的效率很高的原因，因为它是在合成线程里完成的。所以如果是用transform写的动画，如果主线程阻塞了，它都不会卡的**

    合成信息把这些指引信息交给GPU进程，再由GPU进程调用计算机的GPU硬件，生成画面

- 浏览器在渲染的时候会自动优化的，如果你的改动没有导致前面步骤的变动，就不会变的，比如，滚动条滚动，这个动作仅仅是需要光栅化和画这一步改就行，上面的步骤不用重新执行的，所以滚动条滚动时候，就算主线程阻塞了了，也一样可以滚，因为最后两步不在主线程的渲染上面

## reflow和repaint

- reflow：指的是浏览器重新计算布局树，当操作影响了布局树的时候，会reflow，为了避免多次的操作导致布局树反复计算的情况，

  浏览器会合并这些操作后再同一进行，所以，改动属性造成的reflow是异步的

​       但是也是这样的情况，当js获取布局树时候，会获取不到最新的布局树，所以，如果是有获取的操作，浏览器还是会立即更新的，不 

​       会合并后再操作。所以，如果是获取数据，那么就会立即重新布局

- repaint：它的本质就是根据分层的信息重新绘制，也就是差不多上面的画这一步，可见样式变化后，就会导致repaint，reflow一定会导致repaint

## js可以实现精准计时吗，

不可以，计算机硬件中，没有原子钟，不能精准计时

操作系统的计时函数本身就有偏差，js的计时器最终调用的是操作系统的计时器

根据w3c标准：如果计时器嵌套超过了5层，会带有4毫秒的最少偏差，就是五层以上，延迟时间写的不足4毫秒，按照4毫秒算

受事件循环的影响，计时器的回调函数只有在主线程空闲时候才会执行，带来偏差

## vue2的响应式原理

- 一般回答： 遍历数据对象的每个属性，每个属性通过object.defindPropety()方式设置setter和getter 。render函数在运行的时候用到了响应式数据的话，对应的getters收集这个依赖，当数据发生变化的时候，会通知watch，watch会重新派发，让render函数重新运行。

- 具体过程

  首先Observer内部构造器会让所有的属性通过definePropety方式变成了响应式，也就是读取或者设置的时候可以做些事。这个过程在beforcreate和created之间

  > 注意：如果后面还想在数据对象里添加新的响应式数据，理论上是没有办法的，因为响应式的设置过程已经过了，但是vue提供   了内部的方法  $set(obj , attri , value)   obj：之设定成过的响应式的对象 ， attri:想要新添加响应式的属性名 value：属性值

  - depend：在observer的过程中，也就是在创建响应式数据的时候，会对每个对象本身、对象的属性本身、数组本身创建一个dep对象。这个dep对象主要做两件事。一是在调用getter的时候，记录依赖，也就是记录哪些函数（不一定只是render函数）使用了我这个数据。第二就是在setter时候派发更新，也就是告诉哪些函数，我变了，你要重新执行下了

    > 这个也就是说，在vue中，如果你改动了一个响应式数据，但是这个响应式数据如果没有记录render函数这个依赖，是不会重新渲染的

  - watch:主要就是为了解决在observer过程时候，属性getter、setter被调用的时候，如何记录对应的dep函数以及派发（也就是对上一步详解）。

    首先函数在运行时候，不是直接执行，而是交给一个Watch里面执行，在这个watch里面执行函数之前，会设置一个全局变量指定当前的watch。然后再执行watch里面的函数，这时候执行这个函数的时候调用到用到的数据的getter的时候，会通过dep检查全局变量，从而获取到是哪个watch在执行，也就获取到了哪个函数在使用数据。同样的，在这个数据被setter的时候，就可以通知对应的watch，让watch执行自身里面的函数

    > 也就是函数都是放在对应的watch里面执行的，在vue组件中，因为每个组件都会有render函数，所以在打印vue组件实例时候，会在里面看到至少一个watch的。这个watch指的就是render函数。
    >
    > 总结就是：getter记录对应的watch，setter通知watch

  - 调度器（schedule）：就是在数据在变化的时候，如果一个数据，连续变化几次，那么理论上，每次变化都要重新执行对应的watch。但是实际过程中个，不会每次都这样。每次变化确实是都会触发一次watch，但是watch不是每次被触发后就立刻执行，而是把自己交给调度器队列。调度器队列就记录了所有要执行的watch，这个队列里不会重复加相同的watch，所以如果同时提交了相同的watch，调度器队列也就只存在一个watch。然后通过nextTick方法，把这个队列放到微队列中，异步的执行对应的watch，也就是同步代码执行后才会执行watch

    > 所以vue中，第一次render函数是同步执行的，记录对应的dep依赖和watch，在后面如果数据变化，触发watch，也就是触发render函数时候，因为watch是最后被放在微队列中，微队列是异步执行的。所以后续的组件渲染是异步的。这也解释了在vue的渲染是异步的原因
